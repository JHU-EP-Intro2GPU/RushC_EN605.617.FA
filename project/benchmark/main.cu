// C
#include <stdint.h>

// C++
#include <array>
#include <initializer_list>
#include <iomanip>
#include <iostream>
#include <vector>
#include <tuple>

// utils
#include <utils/cuda.cuh>
#include <utils/timing.hpp>
#include <utils/units.hpp>

// libaes
#include <aes/ctr.hpp>

// cuaes
#include <cuaes/ctr.cuh>

using namespace utils::literals;
using namespace utils::operators;

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

/// Resolution of the timing metrics.
using Timing = std::chrono::milliseconds;

/// The size of each column in the output table.
constexpr size_t COLUMN_SIZE = 15;

/// Size of the keys to generate for each test case.
constexpr size_t KEY_SIZE = aes::KEY_SIZE(aes::Type::AES_256);

/// Size of the nonces to generate for each test case.
constexpr size_t NONCE_SIZE = aes::NONCE_SIZE;

/// The plaintext data sizes to test.
static const std::initializer_list<utils::MemorySize> DATA_SIZES = 
{
    16_B, 512_B, 1_kB, 64_kB, 1_MB, 32_MB, 1_GB
};

//------------------------------------------------------------------------------
// Types
//------------------------------------------------------------------------------

/// Represents a single AES-CTR test case.
struct TestCase
{
    std::vector<uint8_t> key;
    std::vector<uint8_t> nonce;
    std::vector<uint8_t> plaintext;
};

//------------------------------------------------------------------------------
// Utilities
//------------------------------------------------------------------------------

/**
 * Print a value aligned to a column
 * 
 * @tparam T The type of value to print.
 *
 * @param[in] value        The value to print.
 * @param[in] column_width The width of the column to align the value to.
 */
template<typename T>
void print_column(const T& value, size_t column_width = COLUMN_SIZE)
{
    std::cout << std::setw(column_width) << value;
}

/**
 * Print a divider.
 * 
 * @param[in] num_columns  The number of columns the divider should span.
 * @param[in] divider_char The character to use to compose the divider.
 * @param[in] column_width The width of the columns.
 */
void print_divider(size_t num_columns, 
                   char divider_char = '-', 
                   size_t column_width = COLUMN_SIZE)
{
    char original_fill = std::cout.fill();
    std::cout << std::setfill(divider_char) 
              << std::setw(column_width * num_columns) 
              << ""
              << std::endl
              << std::setfill(original_fill);
}

/**
 * Print a row of values aligned to columns.
 * 
 * @tparam Iterable The type of container for the values.
 *
 * @param[in] label  The row label.
 * @param[in] values The values to print.
 */
template<typename Iterable>
void print_row(const char label[], 
               const Iterable& values, 
               size_t column_width = COLUMN_SIZE)
{
    print_column(label, column_width);
    for (const auto& value : values)
    {
        print_column(value, column_width);
    }
    std::cout << std::endl;
}

/**
 * Generate random bytes.
 * 
 * @param[in] num_bytes The number of random bytes to generate.
 *
 * @return the randomly generated bytes.
 */
std::vector<uint8_t> random_bytes(size_t num_bytes)
{
    std::vector<uint8_t> bytes(num_bytes);
    
    srand(static_cast<unsigned>(time(nullptr)));
    for (uint8_t& byte : bytes)
    {
        byte = static_cast<uint8_t>(rand());
    }

    return bytes;
}

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Measure how long it takes to perform AES-CTR encryption using libaes.
 * 
 * @param test_case The test data to perform encryption on.
 *
 * @return The time (in microseconds) the encryption took.
 */
Timing time_libaes(const TestCase& test_case)
{
    aes::Type type = aes::TYPE(test_case.key.size());

    std::vector<uint8_t> ciphertext(test_case.plaintext.size());

    return utils::time_it<Timing>([&]
    {
        aes::aes_ctr_encrypt(type, 
                             test_case.key.data(), 
                             test_case.nonce.data(), 
                             test_case.plaintext.data(),
                             test_case.plaintext.size(),
                             ciphertext.data());
    });
}

/**
 * Measure how long it takes to perform AES-CTR encryption using cuaes.
 * 
 * @param test_case The test data to perform encryption on.
 *
 * @return The time (in microseconds) the encryption took.
 */
Timing time_cuaes(const TestCase& test_case)
{
    cuaes::Type type = cuaes::TYPE(test_case.key.size());

    std::vector<uint8_t> host_ciphertext(test_case.plaintext.size());

    return utils::time_it<Timing>([&]
    {
        utils::PagedCudaBuffer<uint8_t> device_key(test_case.key.size());
        utils::PagedCudaBuffer<uint8_t> device_nonce(test_case.nonce.size());
        utils::PagedCudaBuffer<uint8_t> device_plaintext(test_case.plaintext.size());
        utils::PagedCudaBuffer<uint8_t> device_ciphertext(device_plaintext.size());

        device_key.copy_from(test_case.key.data());
        device_nonce.copy_from(test_case.nonce.data());
        device_plaintext.copy_from(test_case.plaintext.data());

        cuaes::aes_ctr_encrypt(type, 
                               device_key.ptr(), 
                               device_nonce.ptr(), 
                               device_plaintext.ptr(),
                               device_plaintext.size(),
                               device_ciphertext.ptr());
        
        device_ciphertext.copy_to(host_ciphertext.data());
    });
}

//------------------------------------------------------------------------------
// Main
//------------------------------------------------------------------------------

int main()
{
    try
    {
        // Note: Much like the first pancake in a batch, the first CUDA kernel
        //       is never quite right; it always takes a little bit longer. So
        //       let's quickly perform a kernel call before we start collecting
        //       timings so we don't end up with any weird results.
        TestCase test_case;
        test_case.key = random_bytes(KEY_SIZE);
        test_case.nonce = random_bytes(NONCE_SIZE);
        test_case.plaintext = random_bytes(16);
        time_cuaes(test_case);

        std::vector<Timing> cpu_timings = {};
        std::vector<Timing> gpu_timings = {};

        for (auto data_size : DATA_SIZES)
        {
            TestCase test_case;
            test_case.key = random_bytes(KEY_SIZE);
            test_case.nonce = random_bytes(NONCE_SIZE);
            test_case.plaintext = random_bytes(data_size.bytes());

            cpu_timings.push_back(time_libaes(test_case));
            gpu_timings.push_back(time_cuaes(test_case));
        }

        print_row("Plaintext Size:", DATA_SIZES);
        print_divider(DATA_SIZES.size() + 1);
        print_row("libaes (CPU):", cpu_timings);
        print_row("cuaes (GPU):", gpu_timings);
    }
    catch (const utils::CudaException& e)
    {
        std::cerr << "CUDA Error: " << e.what() << std::endl;
    }
}
